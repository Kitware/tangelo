#!${PYTHON_EXECUTABLE}

import argparse
import cherrypy
import cherrypy.lib.static
import cherrypy.process.plugins
import datetime
import HTMLParser
import imp
import itertools
import json
import md5
import os
import os.path
import platform
import signal
import subprocess
import sys
import tangelo
import threading
import traceback
import time
import types
from ws4py.server.cherrypyserver import WebSocketPlugin, WebSocketTool
from ws4py.websocket import WebSocket
from autobahn.websocket import connectWS
from autobahn.wamp import WampClientProtocol, WampClientFactory
from twisted.internet import reactor

# A function to run as a before_handler hook that examines a request path and
# "normalizes" it, either by appending a slash or "index.html", etc.
def treat_url():
    reqpath = cherrypy.request.path_info
    webroot = cherrypy.config.get("webroot")

    # Clear the "filepath" property in the thread storage.
    cherrypy.thread_data.target = None

    # Special cases.
    if reqpath == "":
        raise cherrypy.HTTPRedirect("/")
    elif reqpath == "/":
        raise cherrypy.InternalRedirect("/index.html")

    # If we make it here, then reqpath has nonzero length, and its first
    # character should always be a slash.
    assert reqpath[0] == "/"

    # Split the request path into path components, omitting the leading slash.
    reqpathcomp = reqpath[1:].split("/")

    # Compute the disk path the URL corresponds to.
    #
    # First check to see whether the path is absolute (i.e. rooted at webroot)
    # or in a user home directory.
    if reqpathcomp[0][0] == "~" and len(reqpathcomp[0]) > 1:
        # Only treat this component as a home directory if there is actually
        # text following the tilde (rather than making the server serve files
        # from the home directory of whatever user account it is using to run).
        pathcomp = [os.path.expanduser(reqpathcomp[0]) + os.path.sep + "tangelo_html"] + reqpathcomp[1:]
    else:
        pathcomp = [webroot] + reqpathcomp

    # If pathcomp has more than one element, fuse the first two together.  This
    # makes the search for a possible service below much simpler.
    if len(pathcomp) > 1:
        pathcomp = [pathcomp[0] + os.path.sep + pathcomp[1]] + pathcomp[2:]

    # Form an actual path string.
    path = os.path.sep.join(pathcomp)

    # If the path is a directory, check for a trailing slash.  If missing,
    # perform a redirect to the path WITH the trailing slash.  Otherwise, check
    # for an index.html file in that directory; if found, perform an internal
    # redirect to that file.  Otherwise, leave the path alone - it now
    # represents a request for a directory listing.
    #
    # If instead the path isn't a directory, check to see if it's a regular
    # file.  If it is, save the path in thread local storage - this will let the
    # handler very quickly serve the file.
    #
    # If it is not a regular file, then check to see if it is a python service.
    #
    # Finally, if it is none of the above, then raise a 404 error.
    if os.path.isdir(path):
        if reqpath[-1] != "/":
            raise cherrypy.HTTPRedirect(reqpath + "/")
        elif os.path.exists(path + os.path.sep + "index.html"):
            raise cherrypy.InternalRedirect(reqpath + "index.html")
        else:
            cherrypy.thread_data.target = { "type": "dir",
                                            "path": path }
    elif os.path.exists(path):
        cherrypy.thread_data.target = { "type": "file",
                                        "path": path }
    else:
        service_path = None
        pargs = None
        for i, comp in enumerate(pathcomp):
            service_path = os.path.sep.join(pathcomp[:(i+1)]) + ".py"
            if os.path.exists(service_path):
                pargs = pathcomp[(i+1):]
                break

        if pargs is None:
            cherrypy.thread_data.target = { "type": "404" }
        else:
            cherrypy.thread_data.target = { "type": "service",
                                            "path": service_path,
                                            "pargs": pargs }

def auth_update():
    tangelo.log("auth_update: %s" % (cherrypy.request.path_info))

    path_info = cherrypy.request.path_info

    #cherrypy.request.path_info += "lkjdslfkjds"

class WebSocketLowPriorityPlugin(WebSocketPlugin):
    def __init__(self, *pargs, **kwargs):
        WebSocketPlugin.__init__(self, *pargs, **kwargs)

    # This version of start() differs only in that it has an assigned priority.
    # The default priority is 50, which is what the actual WebSocketPlugin's
    # start method gets, which means it runs before the privilege drop gets a
    # chance to (priority 77, slightly lower than the 75 of the engine start
    # itself).  For some reason if this runs before the priv drop, things get
    # screwed up.
    def start(self):
        WebSocketPlugin.start(self)
    start.priority = 80

class WebSocketHandler(object):
    @cherrypy.expose
    def index(self):
        return "OK"

    @cherrypy.expose
    def ws(self):
        pass

def VTKWebSocketAB(url, relay):
    class RegisteringWebSocketClientFactory(WampClientFactory):
        def register(self, client):
            self.client = client

    class Protocol(WampClientProtocol):
        def onOpen(self):
            self.factory.register(self)

        def onMessage(self, msg, is_binary):
            relay.send(msg)

    class Connection(threading.Thread):
        def run(self):
            self.factory = RegisteringWebSocketClientFactory(url)
            self.factory.protocol = Protocol
            reactor.callFromThread(connectWS, self.factory)

        def send(self, data):
            reactor.callFromThread(Protocol.sendMessage, self.factory.client, data)

    c = Connection()
    c.start()
    return c

def WebSocketRelay(hostname, port, key):
    class Class(WebSocket):
        def __init__(self, *pargs, **kwargs):
            WebSocket.__init__(self, *pargs, **kwargs)

            url = "ws://%s:%d/ws" % (hostname, port)

            tangelo.log("websocket created at %s:%d/%s (proxy to %s)" % (hostname, port, key, url))

            self.client = VTKWebSocketAB(url, self)

        def closed(self, code, reason):
            # TODO(choudhury): figure out if recovery, etc. is possible if the
            # socket is closed for some reason.
            tangelo.log("websocket at %s:%d/%s closed with code %d (%s)" % (hostname, port, key, code, reason))
            pass

        def received_message(self, msg):
            self.client.send(msg.data)

    return Class

class Server(object):
    # An HTML parser for use in the error_page handler.
    html = HTMLParser.HTMLParser()

    # A list of acceptable authentication types.
    allowed_auth_types = ["digest"]

    def __init__(self, auth, vtkweb_ports=None):
        # A boolean indicating whether to perform HTTP authentication or not.
        self.auth = auth

        # A dict containing information about imported modules.
        self.modules = {}

        # A dict containing information about currently installed authentication
        # handlers.
        self.security = {}

        # A dict containing currently running streaming data sources.
        self.streams = {}

        # A set containing available ports for running VTK Web processes on, and
        # a dict mapping keys to such processes.
        #
        # TODO(choudhury): use a deque instead, so port numbers can be tried in
        # order in case one of them goes wrong (like there's another program
        # sitting on a port, etc.) (Be sure to count how many ports have been
        # tried, in case all of them are bad ;) ).
        self.vtkweb_ports = set(vtkweb_ports or [])
        self.vtkweb_processes = {}

        tangelo.log("port pool for vtkweb processes: %s" % (str(list(self.vtkweb_ports))))

    def cleanup(self):
        # Terminate the VTK web processes.
        for p in self.vtkweb_processes.values():
            p["process"].terminate()
            p["process"].wait()

    @staticmethod
    def error_page(status, message, traceback, version):
        message = Server.html.unescape(message)
        return """<!doctype html>
<h2>%s</h2>
<p>%s
<hr>
<p><em>Powered by Tangelo</em> <img src=/img/tangelo.ico>""" % (status, message)

    @staticmethod
    def parse_htaccess(filename):
        result = {"msg": None,
                  "auth_type": None,
                  "user_file": None,
                  "realm": None,
                  "userpass": None}

        # Try to open and parse the file.
        try:
            with open(filename) as f:
                lines = filter(lambda x: len(x) > 0, map(lambda x: x.strip().split(), f.readlines()))
                keys = map(lambda x: x[0], lines)
                values = map(lambda x: " ".join(x[1:]), lines)

                for i, (k, v) in enumerate(zip(keys, values)):
                    if k == "AuthType":
                        if v not in Server.allowed_auth_types:
                            result["msg"] = "%s is not a supported authentication type.  The supported types are: %s" % (v, ", ".join(Server.allowed_auth_types))
                            return result
                        else:
                            result["auth_type"] = v
                    elif k in ["AuthPasswordFile", "AuthUserFile"]:
                        result["user_file"] = v
                    elif k == "AuthRealm":
                        result["realm"] = v
                    else:
                        result["msg"] = "Unknown key '%s' on line %d of file '%s'" % (k, i+1, filename)
                        return result
        except IOError:
            result["msg"] = "Could not open file '%s'" % (filename)
            return result

        # Open the user file and parse out the username/passwords of those users
        # in the correct realm.
        recs = None
        if result["user_file"] is not None:
            try:
                with open(result["user_file"]) as f:
                    recs = filter(lambda x: x[1] == result["realm"], map(lambda x: x.strip().split(":"), f.readlines()))
            except IOError:
                result["msg"] = "Could not open user password file '%s'" % (result["user_file"])
                return result
            except IndexError:
                result["msg"] = "Malformed content in user password file '%s' (some line has too few fields)" % (result["user_file"])
                return result

        try:
            result["userpass"] = {x[0]: x[2] for x in recs}
        except IndexError:
            result["msg"] = "Malformed content in user password file '%s' (some line has too few fields)" % (result["user_file"])
            return result

        return result

    def invoke_service(self, module, *pargs, **kwargs):
        # TODO(choudhury): This method should attempt to load the named module,
        # then invoke it with the given arguments.  However, if the named module
        # is "config" or something similar, the method should instead launch a
        # special "config" app, which lists the available app modules, along
        # with docstrings or similar.  It should also allow the user to
        # add/delete search paths for other modules.
        tangelo.content_type("text/plain")

        # Save the system path (be sure to *make a copy* using the list()
        # function) - it will be modified before invoking the service, and must
        # be restored afterwards.
        origpath = list(sys.path)

        # By default, the result should be a bare response that we will place an
        # error message in if something goes wrong; if nothing goes wrong this
        # will be replaced with some other object.
        result = tangelo.empty_response()

        # Store the modpath in the thread-local storage (tangelo.paths() makes
        # use of this per-thread data, so this is the way to get the data across
        # the "module boundary" properly).
        modpath = os.path.dirname(module)
        cherrypy.thread_data.modulepath = modpath

        # Extend the system path with the module's home path.
        sys.path.insert(0, modpath)

        # Import the module if not already imported previously (or if the module
        # to import has been updated since the last import).
        try:
            stamp = self.modules.get(module)
            mtime = os.path.getmtime(module)
            if stamp is None or mtime > stamp["mtime"]:
                tangelo.log("loading new module: " + module)
                # Remove .py to get the module name
                name = module[:-3]
                service = imp.load_source(name, module)
                self.modules[module] = {"module": service, "mtime": mtime}
            else:
                service = stamp["module"]
        except:
            bt = traceback.format_exc()

            tangelo.log("Error importing module %s" % (tangelo.request_path()), "SERVICE")
            tangelo.log(bt, "SERVICE")

            result = tangelo.HTTPStatusCode("501 Error in Python Service", "There was an error while trying to import module %s:<br><pre>%s</pre>" % (tangelo.request_path(), bt))
        else:
            # Try to run the service - either it's in a function called "run()",
            # or else it's in a REST API consisting of at least one of "get()",
            # "put()", "post()", or "delete()".
            #
            # Collect the result in a variable - depending on its type, it will be
            # transformed in some way below (by default, to JSON, but may also raise
            # a cherrypy exception, log itself in a streaming table, etc.).
            #
            try:
                if 'run' in dir(service):
                    # Call the module's run() method, passing it the positional and
                    # keyword args that came into this method.
                    result = service.run(*pargs, **kwargs)
                else:
                    # Reaching here means it's a REST API.  Check for the
                    # requested method, ensure that it was marked as being part
                    # of the API, and call it; or give a 405 error.
                    method = cherrypy.request.method
                    restfunc = service.__dict__[method.lower()]
                    if restfunc is not None and hasattr(restfunc, "restful") and restfunc.restful:
                        result = restfunc(*pargs, **kwargs)
                    else:
                        result = tangelo.HTTPStatusCode(405, "Method not allowed")
            except Exception as e:
                bt = traceback.format_exc()

                tangelo.log("Caught exception while executing service %s" % (tangelo.request_path()), "SERVICE")
                tangelo.log(bt, "SERVICE")

                result = tangelo.HTTPStatusCode("501 Error in Python Service", "There was an error executing service %s:<br><pre>%s</pre>" % (tangelo.request_path(), bt))

        # Restore the path to what it was originally.
        sys.path = origpath

        # Check the type of the result to decide what result to finally return:
        #
        # 1. If it is an HTTPStatusCode object, raise a cherrypy HTTPError
        # exception, which will cause the browser to do the right thing.
        #
        # 2. TODO: If it's a Python generator object, log it with the Tangelo
        # streaming API.
        #
        # 3. If it's a Python dictionary, convert it to JSON.
        #
        # 4. If it's a string, don't do anything to it.
        #
        # This allows the services to return a Python object if they wish, or to
        # perform custom serialization (such as for MongoDB results, etc.).
        if isinstance(result, tangelo.HTTPStatusCode):
            if result.msg:
                raise cherrypy.HTTPError(result.code, result.msg)
            else:
                raise cherrypy.HTTPError(result.code)
        elif "next" in dir(result):
            # Generate a key corresponding to this object, using 100 random
            # bytes from the system - ensure the random key is not already in
            # the table (even though it would be crazy to wind up with a
            # collision).
            #
            # TODO(choudhury): replace this with a call to generateNewKey().
            # Move the comment above into the generateNewKey() function.
            key = md5.md5(os.urandom(100)).hexdigest()
            while key in self.streams:
                key = md5.md5(os.urandom(100)).hexdigest()

            # Log the object in the streaming table.
            self.streams[key] = result

            # Create an object describing the logging of the generator object.
            result = tangelo.empty_response()
            result["stream_key"] = key

            # Serialize it to JSON.
            result = json.dumps(result)
        elif not isinstance(result, types.StringTypes):
            try:
                result = json.dumps(result)
            except TypeError as e:
                t = e.message.split("<service.")[1].split()[0]
                msg = "Service %s returned an object of type %s that could not be serialized to JSON" % (tangelo.request_path(), t)

                tangelo.log("Error: %s" % (msg), "SERVICE")

                raise cherrypy.HTTPError("501 Error in Python Service", msg)

        return result

    @staticmethod
    def dirlisting(dirpath, reqpath):
        if reqpath[-1] == "/":
            reqpath = reqpath[:-1]
        files = filter(lambda x: len(x) > 0 and x[0] != ".", os.listdir(dirpath))
        #filespec = ["Type", "Name", "Last modified", "Size"]
        filespec = []
        for f in files:
            p = dirpath + os.path.sep + f
            s = os.stat(p)
            mtime = datetime.datetime.fromtimestamp(s.st_mtime).strftime("%Y-%m-%d %H:%M:%S")

            if os.path.isdir(p):
                f += "/"
                t = "dir"
                s = "-"
            else:
                t = "file"
                s = s.st_size

            filespec.append([t, "<a href=\"%s/%s\">%s</a>" % (reqpath, f, f), mtime, s])

        filespec = "\n".join(map(lambda row: "<tr>" + "".join(map(lambda x: "<td>%s</td>" % x, row)) + "</tr>", filespec))

        result = """<!doctype html>
<title>Index of %s</title>
<h1>Index of %s</h1>
<table>
<tr>
    <th>Type</th><th>Name</th><th>Last Modified</th><th>Size</th>
</tr>
%s
</table>
""" % (reqpath, reqpath, filespec)

        #return "<!doctype html><h1>Directory Listing</h1>This is a dummy directory listing placeholder."
        return result

    def htaccess(self, htfile, path_info):
        # TODO(choudhury): look at
        # /usr/lib/python2.7/site-packages/cherrypy/lib/auth_digest.py and
        # /usr/lib/python2.7/site-packages/cherrypy/test/test_auth_digest.py for
        # examples of how to do digest auth.  Will want to have users use a
        # tangpass sort of script to generate .htaccess files, so the digest
        # method can remain consistent.
        #
        # May also want to include a basic auth path as well, perhaps depending
        # on a key/value in the .htaccess file itself.

        reload_page = None

        # If there is no htfile, then ensure that the path is unregistered from
        # the security dict, and unregister the config found there.  Otherwise,
        # parse the htfile and add whatever is found there to the security
        # registry and the application configuration.
        if htfile is None:
            if path_info in self.security:
                del self.security[path_info]
                #self.app.pop(path_info, None)

                # TODO(choudhury): this is an attempt to disable an existing
                # tool - verify that this works.  It is meant to replace the
                # commented-out line above.
                cfg = cpserver.config[path_info]
                for a in Server.allowed_auth_types:
                    key = "tools.auth_%s.on" % (a)
                    if key in cfg:
                        cfg[key] = False
                        break
                cpserver.merge({path_info: cfg})
                reload_page = False
        else:
            # Stat the file specifically to learn it's last-modified time.
            ht_mtime = os.stat(htfile).st_mtime

            if path_info not in self.security or ht_mtime > self.security[path_info]:
                # We have found an htaccess file - if there is NO ENTRY in the
                # security table, OR there IS an entry but the htaccess file is
                # NEWER than the one used to create that entry, then we need to
                # parse the file and insert (or update) the record in the table.
                htspec = Server.parse_htaccess(htfile)
                if htspec["msg"]:
                    tangelo.log("Could not register %s: %s" % (path_info, htspec["msg"]), "HTACCESS")
                    return (False, htspec["msg"])

                # Declare an auth config object using the values in the HtAccess
                # object.
                toolname = "tools.auth_%s.%s" % (htspec["auth_type"], "%s")
                passdict = lambda realm, username: htspec["userpass"].get(username)
                auth_conf = {toolname % "on": True,
                             toolname % "realm": htspec["realm"],
                             toolname % "get_ha1": passdict,
                             toolname % "key": "deadbeef"}

                cpserver.merge({path_info: auth_conf})

                # Store the htfile's last-modified time.
                self.security[path_info] = ht_mtime
                reload_page = True

        return (reload_page, None)

    @cherrypy.expose
    def default(self, *path, **args):
        target = cherrypy.thread_data.target
        if target is not None:
            if target["type"] == "file":
                return cherrypy.lib.static.serve_file(target["path"])
            elif target["type"] == "dir":
                return Server.dirlisting(target["path"], cherrypy.request.path_info)
            elif target["type"] == "service":
                return self.invoke_service(target["path"], *target["pargs"], **args)
            elif target["type"] == "404":
                raise cherrypy.lib.static.serve_file("/" + "/".join(path))
            else:
                raise RuntimeError("Illegal target type '%s'" % (target["type"]))

        assert False, "Illegal fall-through"

        # Convert the path argument into a list (from a tuple).
        path = list(path)

        # If there are no positional arguments, behave as though the root
        # index.html was requested.
        if len(path) == 0:
            path = ["index.html"]

        # Check the first character of the first path component.  If it's a
        # tilde, then assume the path points into a user's home directory.
        if path[0][0] == "~":
            # Only treat this component as a home directory if there is actually
            # text following the tilde (rather than making the server serve
            # files from the home directory of whatever user account it is using
            # to run).
            if len(path[0]) > 1:
                # Expand the home directory, append the tangelo_html
                # subdirectory, and then the tail of the original path.
                path = os.path.expanduser(path[0]).split(os.path.sep) + ["tangelo_html"] + path[1:]
        else:
            # TODO(choudhury): check a table of configured custom mappings to
            # see if the first path component should be mapped to some other
            # filesystem path.

            # Reaching this point means the path is relative to the server's web
            # root.
            path = [cherrypy.config.get("webroot")] + path

        # Form a path name from the path components.
        finalpath = os.path.sep.join(path)

        # If the path represents a directory, assume the request is for an
        # index.html file (look for an index.htm as a backup, and as a last
        # resort, assume the user wants to see a directory listing).
        #
        # As this transformation is taking place, use the information to
        # possibly modify the request path info as well.
        reqpath = cherrypy.request.path_info
        if reqpath[-1] == "/":
            reqpath = reqpath[:-1]
        if os.path.isdir(finalpath):
            # If the URL is a directory, but without a trailing slash, redirect
            # to the equivalent URL *with* a trailing slash.
            if cherrypy.request.path_info == "" or cherrypy.request.path_info[-1] != "/":
                raise cherrypy.HTTPRedirect(cherrypy.request.path_info + "/")

            if os.path.exists(finalpath + os.path.sep + "index.html"):
                path += ["index.html"]
                finalpath += os.path.sep + "index.html"
                reqpath += "/index.html"
            elif os.path.exists(finalpath + os.path.sep + "index.htm"):
                path += ["index.htm"]
                finalpath += os.path.sep + "index.htm"
                reqpath += "/index.htm"
            else:
                finalpath += os.path.sep
                reqpath += "/"

        # Check to see whether the path is protected by an .htaccess file
        # (anywhere in either the requested path's directory itself, or any
        # ancestor directory).
        if self.auth:
            # Get the list of path components.
            reqpathcomp = reqpath.split("/")

            # If the request path is for a directory, it will end in a slash, so
            # the component list will end in an empty string.  In this case,
            # remove it.
            if reqpathcomp[-1] == "":
                reqpathcomp = reqpathcomp[:-1]

            # Now begin checking each directory up to the root for an updated
            # .htaccess file.  Do so by stripping in parallel an equal sized
            # suffix of both the file path and request path component lists.
            diff = len(path) - len(reqpathcomp)
            for i in range(len(reqpathcomp), 0, -1):
                done = False

                rqp = "/".join(reqpathcomp[:i])
                fp = os.path.sep.join(path[:(i+diff)])

                # Special case detection - if we wind up with rqp as "" or "/", then
                # this means we have reached the web root and it is the last case we
                # need to check.  Furthermore, if we arrived here by going one level
                # up from someone's private web directory (e.g. from "/~roni") then
                # we need to reset the filepath to point at the web root as well.
                if rqp in ["", "/"]:
                    done = True
                    rqp = "/"
                    fp = current_dir + os.path.sep + "web"

                # Create the full disk path to the htaccess file; use None if
                # the file doesn't exist.
                htfile = fp + "/.htaccess"
                if not os.path.exists(htfile):
                    htfile = None

                # Call the htaccess() method to process the file - by installing
                # a new handler, updating an existing handler, or removing it.
                reload_page, msg = self.htaccess(htfile, rqp)
                if msg is not None:
                    raise cherrypy.HTTPError(401, "There was an error in the HTTP authentication process: %s" % (msg))

                # This is a hack to prevent the page from loading the very first
                # time its htaccess handler is installed.  In the future, this
                # needs to be taken care of in a before_request handler of some
                # kind.
                if reload_page:
                    raise cherrypy.HTTPRedirect(cherrypy.request.path_info)

                if done:
                    break

        # If the reqpath represents a directory (besides the web root), remove
        # the trailing slash.
        if reqpath == "":
            reqpath = "/"
        elif reqpath[-1] == "/":
            reqpath = reqpath[:-1]

        # Check the path components for a .py file.  If we find one, we'll take
        # it to mean that (1) the user is trying to invoke that file as a web
        # service and (2) anything appearing after that point in the URL is a
        # positional argument to the service.
        service_path = None
        pargs = None
        for i, p in enumerate(map(lambda x: os.sep.join(x), [path[:i] for i in range(len(path)+1)])):
            if not os.path.isdir(p) and not os.path.exists(p) and os.path.exists(p + ".py"):
                service_path = p + ".py"
                pargs = path[i:]

        # Serve the requested resource.
        if service_path is not None:
            return self.invoke_service(service_path, *pargs, **args)
        elif os.path.isdir(finalpath):
            return Server.dirlisting(finalpath, reqpath)
        else:
            return cherrypy.lib.static.serve_file(finalpath)

    @cherrypy.expose
    def stream(self, key=None, action="next"):
        if action != "show":
            # Check for key parameter.
            if key is None:
                raise cherrypy.HTTPError("400 Required Query Parameter Missing", "The streaming API requires a 'key' query parameter")

            # Check that the key actually exists.
            if key not in self.streams:
                raise cherrypy.HTTPError("404 Key Not Found", "The key '%s' does not reference any existing stream" % (key))

        # Construct a container object.
        result = tangelo.empty_response()

        # Perform the requested action.
        actions = ["next", "delete", "show"]
        if action == "next":
            # Grab the stream in preparation for running it.
            stream = self.streams[key]

            # Attempt to run the stream via its next() method - if this yields a
            # result, then continue; if the next() method raises StopIteration,
            # then there are no more results to retrieve; if any other exception
            # is raised, this is treated as an error.
            try:
                result["stream_finished"] = False
                result["result"] = stream.next()
            except StopIteration:
                result["stream_finished"] = True
                del self.streams[key]
            except:
                del self.streams[key]
                raise cherrypy.HTTPError("501 Error in Python Service", "Caught exception while executing stream service keyed by %s:<br><pre>%s</pre>" % (key, traceback.format_exc()))

        elif action == "delete":
            del self.streams[key]
            result["result"] = "OK"
        elif action == "show":
            raise cherrypy.HTTPError("501 Unimplemented", "The 'show' action in the Tangelo streaming API has not yet been implemented")
        else:
            raise cherrypy.HTTPError("400 Bad Query Parameter", "The 'action' parameter must be one of: %s" % (", ".join(actions)))

        try:
            result = json.dumps(result)
        except TypeError:
            raise cherrypy.HTTPError("501 Bad Response from Python Service", "The stream keyed by %s returned a non JSON-seriazable result: %s" % (key, result["result"]))

        return result

    @cherrypy.expose
    def vtkweb(self, *pargs, **kwargs):
        # TODO(choudhury): Implement a PUT method that expands the pool of
        # usable port numbers.

        # Get keyword arguments.
        progargs = kwargs.get("progargs", "")
        timeout = kwargs.get("timeout", 0)

        # Convert the positional args to a list.
        pargs = list(pargs)

        # Dispatch a RESTful action.
        method = cherrypy.request.method
        if method == "GET":
            # If there is no key argument, send back a list of all the keys.
            if len(pargs) == 0:
                response = self.vtkweb_processes.keys()
            else:
                # Extract the key argument.
                key = pargs[0]

                # Check for the key in the process table.
                if key not in self.vtkweb_processes:
                    return json.dumps({"status": "failed", "reason": "Requested key not in process table"})

                # Retrieve the entry.
                rec = self.vtkweb_processes[key]
                response = {"status": "complete", "process": "running", "port": rec["port"]}
                returncode = rec["process"].poll()
                if returncode is not None:
                    # Since the process has ended, reclaim its resources and delete
                    # the process object.
                    self.vtkweb_ports.add(rec["port"])
                    del self.vtkweb_processes[key]

                    # Fill out the report response.
                    response["process"] = "terminated"
                    response["returncode"] = returncode

                    stdout, stderr = rec["process"].communicate()
                    response["stdout"] = stdout
                    response["stderr"] = stderr

            # Make a report to the user.
            return json.dumps(response)
        elif method == "POST":
            if len(pargs) == 0:
                return json.dumps({"status": "incomplete", "reason": "missing path to vtkweb script"})

            # Form the web path from the pargs components
            progpath = os.path.sep.join(pargs)

            # Verify that all required arguments are present.
            if len(pargs) == 0:
                return json.dumps({"status": "incomplete", "reason": "Missing program URL"})

            # Check the user arguments.
            userargs = progargs.split()
            if "--port" in userargs:
                return json.dumps({"status": "incomplete", "reason": "You may not specify --port in this interface"})

            # Verify that the program path is legal.
            if not tangelo.legal_path(progpath)[0]:
                return json.dumps({"status": "incomplete", "reason": "Illegal program URL"})

            # Obtain a filesystem path to the requested program.
            progfile = tangelo.abspath(progpath)

            # Check for an available port.
            if len(self.vtkweb_ports) == 0:
                # Try to reclaim any dead processes.
                #
                # Collect a list of dead processes by key while reclaiming their
                # port numbers.
                good = False
                delete = []
                tangelo.log(str(self.vtkweb_processes))
                for k, v in self.vtkweb_processes.iteritems():
                    if v["process"].poll() is not None:
                        good = True
                        self.vtkweb_ports.add(v["port"])
                        delete.push(k)

                # Delete the dead entries from the process table.
                for d in delete:
                    del self.vtkweb_processes[d]

                # If no process was dead, tell the user the bad news.
                if not good:
                    return json.dumps({"status": "failed", "reason": "no available ports"})

            # Get a port and generate a unique key.
            port = self.vtkweb_ports.pop()
            key = generateNewKey(self.vtkweb_processes.keys())

            # Launch the requested process.
            try:
                cmdline = ["${VTKPYTHON_EXECUTABLE}", "${CMAKE_BINARY_DIR}/${DEPLOY_DIR}/vtkweb-launcher.py", progfile, "--port", str(port)] + userargs
                tangelo.log("starting a vtkweb process: %s" % (" ".join(cmdline)))
                process = subprocess.Popen(cmdline, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            except OSError as e:
                # On launch failure, replace the port number in the pool, and
                # report the failure to the user.
                self.vtkweb_ports.add(port)
                return json.dumps({"status": "failed", "reason": e.message})

            # Give the vtkweb process time to come up.
            #
            # TODO(choudhury): instead of just waiting one second, communicate
            # with the VTK Web process, verifying that its initial output
            # contains a signal phrase that means it's working (talk to Seb J.).
            time.sleep(1)

            # Create a websocket handler path dedicated to this process.
            host = cherrypy.server.socket_host
            if host == "0.0.0.0":
                host = "localhost"
            wshandler = WebSocketRelay(host, port, key)
            cherrypy.tree.mount(WebSocketHandler(), "/%s" % (key), config={"/ws": {"tools.websocket.on": True, "tools.websocket.handler_cls": wshandler, "tools.websocket.protocols": ["wamp"]}})

            # Log the new process in the process table.
            self.vtkweb_processes[key] = {"port": port, "process": process}

            # Form the websocket URL from the hostname/port used in the request,
            # and the newly generated key.
            url = "ws://%s/%s/ws" % (cherrypy.request.base.split("//")[1], key)
            return json.dumps({"status": "complete", "key": key, "url": url})
        elif method == "DELETE":
            # TODO(choudhury): shut down a vtkweb process by key after a given
            # timeout.

            # Make sure there's a key.
            if len(pargs) == 0:
                return json.dumps({"status": "incomplete", "reason": "'key' argument is REQUIRED"})

            # Extract the key.
            key = pargs[0]
            tangelo.log("shutting down %s" % (key))

            # Check for the key in the process table.
            if key not in self.vtkweb_processes:
                tangelo.log("key not found")
                return json.dumps({"status": "failed", "reason": "no such key in process table"})

            # Terminate the process.
            tangelo.log("terminating process")
            proc = self.vtkweb_processes[key]
            proc["process"].terminate()
            proc["process"].wait()
            tangelo.log("terminated")

            # Reclaim the port number being used by the process, and remove it
            # from the table.
            tangelo.log("reclaiming port %d" % (proc["port"]))
            self.vtkweb_ports.add(proc["port"])
            del self.vtkweb_processes[key]

            return json.dumps({"status": "complete"})
        else:
           raise cherrypy.HTTPError(405, "Method not allowed")

def live_pid(pid):
    try:
        os.kill(pid, 0)
    except OSError:
        return False
    else:
        return True

def read_pid(pidfile):
    # Open the file and convert the contents to an integer - if this fails for
    # any reason, whatever exception is raised will propagate up to the caller.
    with open(pidfile) as f:
        pid = int(f.read())

    return pid

def generateNewKey(taken, randbytes=128):
    key = md5.md5(os.urandom(randbytes)).hexdigest()
    while key in taken:
        key = md5.md5(os.urandom(randbytes)).hexdigest()

    return key

def polite(signum, frame):
    print >>sys.stderr, "Already shutting down.  To force shutdown immediately, send SIGQUIT (Ctrl-\\)."

def die(signum, frame):
    print >>sys.stderr, "Forced shutdown.  Exiting immediately."
    os.kill(os.getpid(), signal.SIGKILL)

def shutdown(signum, frame):
    # Disbale the shutdown handler (i.e., for repeated Ctrl-C etc.) for the
    # "polite" shutdown signals.
    for sig in [signal.SIGINT, signal.SIGTERM]:
        signal.signal(sig, polite)

    # Perform (1) vtkweb process cleanup, (2) twisted reactor cleanup and quit,
    # (3) CherryPy shutdown, and (4) CherryPy exit.
    cpserver.root.cleanup()
    reactor.stop()
    cherrypy.engine.stop()
    cherrypy.engine.exit()

def start(vtkweb_ports=None):
    global cpserver

    sys.stderr.write("starting tangelo...")

    # The presence of a pid file means that either this instance of Tangelo is
    # already running, or the PID is stale.
    if os.path.exists(pidfile):
        # Get the pid.
        try:
            pid = read_pid(pidfile)
        except ValueError:
            sys.stderr.write("failed (pidfile exists and contains bad pid)\n")
            return 1

        # Check if the pid is live - if so, then Tangelo is already running; if
        # not, then remove the pidfile.
        if live_pid(pid):
            sys.stderr.write("failed (already running)\n")
            return 1
        else:
            try:
                os.remove(pidfile)
            except OSError:
                sys.stderr.write("failed (could not remove stale pidfile)")
                return 1

    # Make sure the working directory is the place where the control script
    # lives.
    os.chdir(path)

    # Set up the global configuration.  This includes the hostname and port
    # number as specified in the CMake phase.
    #
    # Whether to log directly to the screen has to do with whether we are
    # daemonizing - if we are, we want to suppress the output, and if we are
    # not, we want to see everything.
    cherrypy.config.update({"environment": "production",
                            "log.error_file": logfile,
                            "log.screen": not daemonize,
                            "server.socket_host": hostname,
                            "server.socket_port": port,
                            "error_page.default": Server.error_page})

    # If we are daemonizing, do it here, before anything gets started.  We have
    # to set this up in a certain way:
    #
    # 1. We fork ourselves immediately, so the child process, which will
    # actually start CherryPy, doesn't scribble on the screen.
    #
    # 2. We get the parent process to poll the logfile for specific messages
    # indicating success or failure, and use these to print an informative
    # message on screen.
    #
    # The special behavior of the parent before it exits is the reason we don't
    # just use the CherryPy Daemonizer plugin.
    if daemonize:
        fork = os.fork()

        # The parent process - start a polling loop to watch for signals in the
        # log file before exiting.
        if fork != 0:
            # Loop until we can open the logfile (this is in case the child
            # process hasn't created it just yet).
            opened = False
            while not opened:
                try:
                    f = open(logfile)
                    opened = True
                except IOError:
                    pass

            # Seek to the end of the file.
            f.seek(0, os.SEEK_END)

            # In a loop, look for new lines being added to the log file, and
            # examine them for signs of success or failure.
            done = False
            while not done:
                cur_pos = f.tell()
                line = f.readline()
                if not line:
                    f.seek(cur_pos)
                else:
                    if "Bus STARTED" in line:
                        retval = 0
                        print >>sys.stderr, "success (serving on %s)" % (location)
                        done = True
                    elif "Error" in line:
                        retval = 1
                        print >>sys.stderr, "failed (check tangelo.log for reason)"
                        done = True
                    elif "Serving on" in line:
                        location = line.split("Serving on")[1].strip()

            # The parent process can now exit, indicating success or failure of
            # the child.
            sys.exit(retval)

    # From this point forward, we are the child process, and can now set up the
    # server and get it going.
    #
    # Create an instance of the main handler object.
    cpserver = cherrypy.Application(Server(do_auth, vtkweb_ports), "/")
    cherrypy.tree.mount(cpserver, config={"/": { "tools.auth_update.on": False,
                                                 "tools.treat_url.on": True }})

    # Try to drop privileges if requested, since we've bound to whatever port
    # superuser privileges were needed for already.
    if drop_priv:
        # If we're on windows, don't supply any username/groupname, and just
        # assume we should drop priveleges.
        if os_name == "Windows":
            cherrypy.process.plugins.DropPrivileges(cherrypy.engine).subscribe()
        elif os.getuid() == 0:
            # Reaching here means we're on unix, and we are the root user, so go
            # ahead and drop privileges to the requested user/group.
            import grp
            import pwd

            # Find the UID and GID for the requested user and group.
            try:
                mode = "user"
                value = user
                uid = pwd.getpwnam(user).pw_uid

                mode = "group"
                value = group
                gid = grp.getgrnam(group).gr_gid
            except KeyError:
                msg = "no such %s '%s' to drop privileges to" % (mode, value)
                tangelo.log(msg, "ERROR")
                print >>sys.stderr, "failed (%s)" % (msg)
                sys.exit(1)

            # Set the process home directory to be the dropped-down user's.
            os.environ["HOME"] = os.path.expanduser("~%s" % (user))

            # Transfer ownership of the log file to the non-root user.
            os.chown(logfile, uid, gid)

            # Perform the actual UID/GID change.
            cherrypy.process.plugins.DropPrivileges(cherrypy.engine, uid=uid, gid=gid).subscribe()

    # If daemonizing, we need to maintain a pid file.
    if daemonize:
        cherrypy.process.plugins.PIDFile(cherrypy.engine, pidfile).subscribe()

    # Set up websocket handling.  Use the pass-through subclassed version of the
    # plugin so we can set a priority on it that doesn't conflict with privilege
    # drop.
    WebSocketLowPriorityPlugin(cherrypy.engine).subscribe()
    cherrypy.tools.websocket = WebSocketTool()

    # Install signal handlers to allow for proper cleanup/shutdown.
    for sig in [signal.SIGINT, signal.SIGTERM]:
        signal.signal(sig, shutdown)

    # Send SIGQUIT to an immediate, ungraceful shutdown instead.
    signal.signal(signal.SIGQUIT, die)

    # Install the "treat_url" tool, which performs redirections and analyzes the
    # request path to see what kind of resource is being requested, and the
    # "auth update" tool, which checks for updated/new/deleted .htaccess files
    # and updates the state of auth tools on various paths.
    cherrypy.tools.treat_url = cherrypy.Tool("before_handler", treat_url, priority=0)
    cherrypy.tools.auth_update = cherrypy.Tool("before_handler", auth_update, priority=1)

    # Start the CherryPy engine.
    cherrypy.engine.start()

    # Start the Twisted reactor in the main thread (it will block but the
    # CherryPy engine has already started in a non-blocking manner).
    reactor.run(installSignalHandlers=False)
    cherrypy.engine.block()

def stop():
    retval = 0
    sys.stderr.write("stopping tangelo...")

    if os.path.exists(pidfile):
        # Read the pid.
        try:
            pid = read_pid(pidfile)
        except ValueError:
            sys.stderr.write("failed (tangelo.pid does not contain a valid process id)\n")
            return 1

        # Attempt to terminate the process, if it's still alive.
        try:
            if live_pid(pid):
                os.kill(pid, signal.SIGTERM)
                while live_pid(pid):
                    time.sleep(0.1)
        except OSError:
            sys.stderr.write("failed (could not terminate process %d)\n" % (pid))
            retval = 1

    if retval == 0:
        sys.stderr.write("success\n")

    return retval

def restart():
    stopval = stop()
    if stopval == 0:
        return start(args.vtkweb_ports)
    else:
        return stopval

if __name__ == "__main__":
    p = argparse.ArgumentParser(description="Control execution of a Tangelo server.")
    p.add_argument("-d", "--no-daemon", action="store_true", help="run Tangelo in-console (not as a daemon).")
    p.add_argument("-a", "--no-auth", action="store_true", help="disable HTTP authentication (i.e. processing of .htaccess files).")
    p.add_argument("-p", "--no-drop-privileges", action="store_true", help="disable privilege drop when started as superuser.")
    p.add_argument("--hostname", type=str, default=None, metavar="HOSTNAME", help="overrides configured hostname on which to run Tangelo")
    p.add_argument("--port", type=int, default=None, metavar="PORT", help="overrides configured port number on which to run Tangelo")
    p.add_argument("--vtkweb-ports", type=str, default=None, metavar="PORT RANGE", help="specifies the port range to use for VTK Web processes")
    p.add_argument("-u", "--user", type=str, default=None, metavar="USERNAME", help="specifies the user to run as when root privileges are dropped")
    p.add_argument("-g", "--group", type=str, default=None, metavar="GROUPNAME", help="specifies the group to run as when root privileges are dropped")
    p.add_argument("--logdir", type=str, default=None, metavar="DIR", help="where to place the log file (rather than in the directory where this program is")
    p.add_argument("--piddir", type=str, default=None, metavar="DIR", help="where to place the PID file (rather than in the directory where this program is")
    p.add_argument("action", metavar="<start|stop|restart>", help="perform this action for the current Tangelo instance.")
    args = p.parse_args()

    no_daemon = args.no_daemon
    do_auth = not args.no_auth
    drop_priv = not args.no_drop_privileges
    action = args.action
    hostname = args.hostname or "@SERVER_HOSTNAME@"
    port = args.port or @SERVER_PORT@
    user = args.user or "@SERVER_USER@"
    group = args.group or "@SERVER_GROUP@"
    logdir = args.logdir
    piddir = args.piddir

    if args.vtkweb_ports is not None:
        try:
            # This parses expressions of the form "8081-8090,12000,13500-13600".
            # It will allow spaces around the punctuation, but reject too many
            # hyphens, and "blank" entries (i.e. two commas next to each other
            # etc.).
            args.vtkweb_ports = itertools.chain.from_iterable(map(lambda y: range(y[0], y[1]) if len(y) == 2 else [y[0]], map(lambda x: map(int, x.split("-", 1)), args.vtkweb_ports.split(","))))
        except ValueError:
            print >>sys.stderr, "error: could not parse VTK Web port range specification '%s'" % (args.vtkweb_ports)
            sys.exit(1)

        if args.vtkweb_ports == []:
            print >>sys.stderr, "error: VTK Web port specification '%s' produces no ports" % (args.vtkweb_ports)
            sys.exit(1)

    # Configured variables.
    cherry = "@CherryPy_EXECUTABLE@"

    # Detect operating system (and OSX version, if applicable).
    os_name = platform.system()
    if os_name == "Darwin":
        version = map(int, platform.mac_ver()[0].split("."))

    # Determine the current directory based on the invocation of this script.
    current_dir = os.path.dirname(os.path.abspath(__file__))
    cherrypy.config.update({"webroot": current_dir + "/web"})

    # Decide whether to daemonize, based on whether the user wishes not to, and
    # whether the platform supports it.
    daemonize = not no_daemon and not(os_name == "Windows" or (os_name == "Darwin" and version[1] == 6))

    # Get the path of the tangelo script.
    path = os.path.dirname(os.path.abspath(sys.argv[0]))

    # Determine the paths to place the PID file and log file in.  This defaults
    # to the same directory that contains the tangelo control script.
    if piddir is None:
        pidpath = path
    else:
        pidpath = os.path.abspath(piddir)
    pidfile = pidpath + "/tangelo.pid"

    if logdir is None:
        logpath = path
    else:
        logpath = os.path.abspath(logdir)
    logfile = logpath + "/tangelo.log"

    # Dispatch on action argument.
    code = 1
    if action == "start":
        code = start(args.vtkweb_ports)
    elif action == "stop":
        if not daemonize:
            sys.stderr.write("error: stop action not supported on this platform\n")
            sys.exit(1)
        code = stop()
    elif action == "restart":
        if not daemonize:
            sys.stderr.write("error: restart action not supported on this platform\n")
            sys.exit(1)
        code = restart()
    else:
        p.print_usage()
        code = 1

    sys.exit(code)
